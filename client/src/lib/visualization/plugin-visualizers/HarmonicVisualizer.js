/**
 * HARMONIC VISUALIZER
 *
 * Static harmonic content analyzer for Saturator plugin.
 * Shows harmonic amplitudes generated by distortion.
 *
 * Features:
 * - 6 harmonic bars (fundamental + 5 overtones)
 * - Distortion-based amplitude
 * - Color-coded bars
 * - Only renders on parameter change (not animated)
 */

import { CanvasPluginVisualizer } from '../CanvasPluginVisualizer';

export class HarmonicVisualizer extends CanvasPluginVisualizer {
  constructor(config) {
    super({
      ...config,
      priority: 'low' // Static, low priority
    });

    // Harmonic configuration
    this.harmonicCount = 6;
    this.harmonicColors = [
      '#00E5B5', // Fundamental (cyan)
      '#FF6B6B', // 2nd harmonic (red)
      '#FFD93D', // 3rd harmonic (yellow)
      '#95E1D3', // 4th harmonic (teal)
      '#AA96DA', // 5th harmonic (purple)
      '#FCBAD3'  // 6th harmonic (pink)
    ];
  }

  /**
   * Main canvas render (called only when parameters change)
   */
  onRenderCanvas(ctx, timestamp, params) {
    const { drive = 50, type = 'tube' } = params;

    // Clear canvas
    this.clear('rgba(10, 14, 26, 0.95)');

    // Calculate distortion factor
    const distortion = drive / 100;

    // Calculate harmonic amplitudes based on distortion type
    const harmonics = this.calculateHarmonics(distortion, type);

    // Draw bars
    const barWidth = this.canvasWidth / this.harmonicCount;
    const barSpacing = 4;
    const maxBarHeight = this.canvasHeight * 0.85;

    harmonics.forEach((harmonic, index) => {
      const x = index * barWidth + barSpacing / 2;
      const width = barWidth - barSpacing;
      const height = harmonic.amplitude * maxBarHeight;
      const y = this.canvasHeight - height;

      // Bar gradient
      const gradient = ctx.createLinearGradient(x, y, x, this.canvasHeight);
      gradient.addColorStop(0, this.harmonicColors[index]);
      gradient.addColorStop(1, this.hexToRGBA(this.harmonicColors[index], 0.3));

      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, width, height);

      // Bar outline
      ctx.strokeStyle = this.harmonicColors[index];
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);

      // Harmonic label
      this.drawText(`${harmonic.freq}Ã—`, x + width / 2, this.canvasHeight - 10, {
        font: '10px Inter, system-ui',
        color: 'rgba(255, 255, 255, 0.6)',
        align: 'center',
        baseline: 'bottom',
        shadowBlur: 0
      });

      // Amplitude label
      if (height > 20) {
        const ampPercent = Math.round(harmonic.amplitude * 100);
        this.drawText(`${ampPercent}%`, x + width / 2, y + 12, {
          font: 'bold 11px Inter, system-ui',
          color: '#0A0E1A',
          align: 'center',
          baseline: 'top',
          shadowBlur: 0
        });
      }
    });

    // Title
    this.drawText('HARMONIC CONTENT', this.canvasWidth / 2, 10, {
      font: 'bold 12px Inter, system-ui',
      color: 'rgba(255, 255, 255, 0.5)',
      align: 'center',
      baseline: 'top',
      shadowBlur: 2
    });
  }

  /**
   * Calculate harmonic amplitudes based on distortion type
   */
  calculateHarmonics(distortion, type) {
    const harmonics = [
      { freq: 1, amplitude: 1 }, // Fundamental
      { freq: 2, amplitude: 0 },
      { freq: 3, amplitude: 0 },
      { freq: 4, amplitude: 0 },
      { freq: 5, amplitude: 0 },
      { freq: 6, amplitude: 0 }
    ];

    // Different harmonic profiles based on saturation type
    switch (type) {
      case 'tube':
        // Tube: Even + odd harmonics, warm character
        harmonics[1].amplitude = distortion * 0.6;  // 2nd (even)
        harmonics[2].amplitude = distortion * 0.5;  // 3rd (odd)
        harmonics[3].amplitude = distortion * 0.3;  // 4th (even)
        harmonics[4].amplitude = distortion * 0.2;  // 5th (odd)
        harmonics[5].amplitude = distortion * 0.12; // 6th (even)
        break;

      case 'tape':
        // Tape: More even harmonics, soft saturation
        harmonics[1].amplitude = distortion * 0.7;  // 2nd (even)
        harmonics[2].amplitude = distortion * 0.35; // 3rd (odd)
        harmonics[3].amplitude = distortion * 0.4;  // 4th (even)
        harmonics[4].amplitude = distortion * 0.18; // 5th (odd)
        harmonics[5].amplitude = distortion * 0.15; // 6th (even)
        break;

      case 'transistor':
        // Transistor: More odd harmonics, harsh character
        harmonics[1].amplitude = distortion * 0.5;  // 2nd (even)
        harmonics[2].amplitude = distortion * 0.65; // 3rd (odd)
        harmonics[3].amplitude = distortion * 0.25; // 4th (even)
        harmonics[4].amplitude = distortion * 0.4;  // 5th (odd)
        harmonics[5].amplitude = distortion * 0.15; // 6th (even)
        break;

      default:
        // Default: balanced harmonics
        harmonics[1].amplitude = distortion * 0.6;
        harmonics[2].amplitude = distortion * 0.4;
        harmonics[3].amplitude = distortion * 0.25;
        harmonics[4].amplitude = distortion * 0.15;
        harmonics[5].amplitude = distortion * 0.1;
    }

    return harmonics;
  }

  /**
   * Convert hex color to RGBA
   */
  hexToRGBA(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  /**
   * Detect parameter changes (override to only listen to drive and type)
   */
  detectParameterChange(params) {
    return (
      params.drive !== this.lastParams.drive ||
      params.type !== this.lastParams.type
    );
  }
}
