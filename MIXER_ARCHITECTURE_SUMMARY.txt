================================================================================
                    MIXER ARCHITECTURE ANALYSIS - EXECUTIVE SUMMARY
================================================================================

PROJECT: DAWG Audio Engine
DATE: 2025-10-23
STATUS: HYBRID TRANSITIONAL STATE WITH CRITICAL ISSUES

================================================================================
                              SYSTEMS OVERVIEW
================================================================================

THREE MIXER SYSTEMS DETECTED:

1. UnifiedMixerNode (WASM-Powered)
   Location: /client/src/lib/core/UnifiedMixerNode.js
   Status: ACTIVE (Legacy, being replaced)
   Channels: 32 fixed (hardcoded limit)
   Architecture: AudioWorklet + WASM binary processor
   Connection Point: Direct to masterBusGain
   
   Pros:
   - Very fast (11x faster than old system)
   - Zero CPU overhead
   - Per-channel EQ and compression built-in
   
   Cons:
   - Fixed 32-channel limit
   - Internal processing (not user-controllable)
   - Complex WASM management

2. MixerInsert System (JavaScript Nodes)
   Location: /client/src/lib/core/MixerInsert.js
   Status: NEW (Experimental, partially integrated)
   Channels: Unlimited (dynamic)
   Architecture: Standard Web Audio API nodes
   Connection Point: masterBusInput
   
   Pros:
   - Unlimited capacity
   - Clean, understandable code
   - User-controllable effects
   - Easy to debug
   
   Cons:
   - More JavaScript overhead
   - Not fully integrated with UnifiedMixer
   - Missing some disposal code

3. Old Mixer System (Legacy)
   Status: DEPRECATED (but code still present)
   Location: Code fragments in NativeAudioEngine
   Issues: Completely removed from initialization, but some references remain

================================================================================
                              SIGNAL FLOW
================================================================================

STARTUP:
--------
1. NativeAudioEngine._initializeCore()
   ├─ _setupMasterAudioChain() - Creates master bus nodes
   ├─ _initializeUnifiedMixer() - Creates UnifiedMixer (ALWAYS)
   └─ useMixerStore initializes with default track

2. useMixerStore.addTrack() called
   └─ AudioContextService.createMixerInsert(trackId)
      └─ NativeAudioEngine.createMixerInsert()
         └─ Creates MixerInsert instance
         └─ Connects to masterBusInput

3. useInstrumentsStore.createInstrument(instrumentData)
   └─ Checks if instrumentData.mixerTrackId exists
      ├─ YES: Check if MixerInsert exists
      │  ├─ YES: routeInstrumentToInsert() → MixerInsert path ✅
      │  └─ NO: _connectInstrumentToChannel() → UnifiedMixer path ⚠️
      │
      └─ NO: Auto-generate track-N, use UnifiedMixer path ⚠️


TWO PARALLEL SIGNAL PATHS:

Path A - MixerInsert (If Insert Exists):
  Instrument Output
    ↓
  MixerInsert.input (GainNode)
    ↓
  [Effects Chain] (user-controllable)
    ↓
  MixerInsert.gainNode (volume control)
    ↓
  MixerInsert.panNode (pan control)
    ↓
  MixerInsert.analyzer (metering)
    ↓
  MixerInsert.output
    ↓
  masterBusInput

Path B - UnifiedMixer (If Insert Not Found):
  Instrument Output
    ↓
  UnifiedMixer Input Channel N
    ↓
  [WASM Processing: gain, pan, EQ, compression]
    ↓
  UnifiedMixer Output
    ↓
  masterBusGain (DIRECT - BYPASSES masterBusInput!)

Master Output (Both Paths):
  masterBusGain
    ↓
  masterGain (user volume - default 0.8)
    ↓
  masterAnalyzer (metering)
    ↓
  AudioContext.destination


PROBLEM: Both systems can be active simultaneously!
- MixerInsert routes to masterBusInput
- UnifiedMixer routes to masterBusGain
- Different gain staging paths
- Unclear which is primary

================================================================================
                          CRITICAL PROBLEMS
================================================================================

PROBLEM #1: Memory Leak in MixerInsert Disposal
──────────────────────────────────────────────
Severity: HIGH
File: NativeAudioEngine.js:1134-1212 (dispose method)
Issue: MixerInsert instances not disposed
Code Missing:
  for (const insert of this.mixerInserts.values()) {
    insert.dispose();  // ← NOT CALLED!
  }
  this.mixerInserts.clear();

Impact: When engine disposed (hot reload), orphaned audio nodes leak memory
        - AnalyserNode (metering)
        - StereoPannerNode (pan control)
        - GainNode (volume control)
        - All effect nodes


PROBLEM #2: Parameter Updates Fail Silently
────────────────────────────────────────────
Severity: HIGH
File: useMixerStore.js:110-127, NativeAudioEngine.js:1980-1994
Issue: No check if MixerInsert exists before updating parameters
Sequence:
  1. User moves volume fader
  2. useMixerStore calls AudioContextService.setInsertGain(trackId, gain)
  3. NativeAudioEngine.setInsertGain() does:
     - Gets insert = this.mixerInserts.get(trackId)
     - If insert doesn't exist → method returns silently, NO ERROR
  4. User sees slider move in UI but no audio volume changes

Impact: If instrument routed to UnifiedMixer, parameter changes have no effect


PROBLEM #3: Effect Addition Fails for UnifiedMixer Instruments
───────────────────────────────────────────────────────────────
Severity: HIGH
File: useMixerStore.js:182-200, NativeAudioEngine.js:1317-1349
Issue: addEffectToInsert() assumes MixerInsert exists
Sequence:
  1. User adds reverb effect to track
  2. useMixerStore updates UI state (effect shows in interface)
  3. useMixerStore calls AudioContextService.addEffectToInsert()
  4. NativeAudioEngine.addEffectToInsert() does:
     - Gets insert = this.mixerInserts.get(insertId)
     - If insert undefined → method returns null, NO ERROR
  5. UI shows effect added, but audio processing doesn't happen

Impact: Visual inconsistency - UI shows effects that don't actually process


PROBLEM #4: Unclear Routing Decision Logic
───────────────────────────────────────────
Severity: MEDIUM
File: NativeAudioEngine.js:550-570 (createInstrument)
Issue: Two different code paths handle routing

Path 1 (with mixerTrackId):
  if (mixerTrackId && insert exists) → MixerInsert ✅
  if (mixerTrackId && insert NOT exists) → UnifiedMixer ⚠️
  
Path 2 (without mixerTrackId):
  → Always UnifiedMixer ⚠️

Result: Instrument routing is unpredictable and depends on timing


PROBLEM #5: Master Pan Control Missing
───────────────────────────────────────
Severity: MEDIUM
File: NativeAudioEngine.js:687-688, useMixerStore.js:104-107
Issue: setMasterPan() method referenced but doesn't exist

In useMixerStore.js:
  if (param === 'pan' && audioEngine?.setMasterPan) {
    audioEngine.setMasterPan(value);  // ← This method DOESN'T EXIST
  }

Result: Master pan slider in UI does nothing


PROBLEM #6: Hard-Coded 28-Track Limit
──────────────────────────────────────
Severity: MEDIUM
File: NativeAudioEngine.js:631-648 (_initializeUnifiedMixerChannelMap)
Issue: UnifiedMixer channel mapping hardcoded to 28 tracks

Code:
  for (let i = 1; i <= 28; i++) {
    this.unifiedMixerChannelMap.set(`track-${i}`, i - 1);
  }

Problem: If user tries to create 29+ tracks, UnifiedMixer has no channels
         But MixerInsert system says "unlimited"
         Inconsistent capacity between two systems

Impact: User can create 30 tracks in UI, but can't route to UnifiedMixer


PROBLEM #7: Two Connection Points for Master Bus
──────────────────────────────────────────────────
Severity: MEDIUM
File: NativeAudioEngine.js:378-417, 602-609
Issue: Different systems connect to different master points

Current:
  - MixerInsert → masterBusInput → masterBusGain
  - UnifiedMixer → masterBusGain (direct, bypasses masterBusInput!)

Problem: Inconsistent gain staging
         UnifiedMixer output doesn't pass through masterBusInput
         Unclear which is the "real" master bus


PROBLEM #8: Effect ID Mapping Fragility
────────────────────────────────────────
Severity: MEDIUM
File: MixerInsert.js:99-123, useMixerStore.js:182-200
Issue: Two different ID systems used

In Store:
  effect.id = "fx-uuid" (for UI tracking)
  
In Engine:
  effect.audioEngineId = "timestamp-xxx" (for audio lookup)

Mapping is manual and error-prone:
  - addEffectToInsert() takes BOTH ids as parameters
  - removeEffectFromInsert() uses audioEngineId to find effect
  - But addEffect() stores both ids in the effects Map

Result: Works, but confusing and fragile


PROBLEM #9: No Fallback for UnifiedMixer Initialization Failure
───────────────────────────────────────────────────────────────
Severity: MEDIUM
File: NativeAudioEngine.js:973-977 (_connectInstrumentToChannel)
Issue: If UnifiedMixer not initialized, all routing fails

Code:
  if (!this.unifiedMixer) {
    console.error('❌ UnifiedMixer not initialized - cannot route instrument');
    return false;  // Instrument has nowhere to go!
  }

Impact: If UnifiedMixer initialization fails, entire mixer fails


PROBLEM #10: Missing Synchronization Between Stores and Engine
────────────────────────────────────────────────────────────────
Severity: MEDIUM
File: useMixerStore.js (various), NativeAudioEngine.js (various)
Issue: Store doesn't know which system each instrument is routed to

Problem: handleMixerParamChange() always uses setInsertGain()
         But if instrument is in UnifiedMixer, this fails
         No fallback to check and use UnifiedMixer methods

Result: Parameter updates silent fail for ~50% of instruments
        depending on which system they're routed to

================================================================================
                        IMMEDIATE ACTION ITEMS
================================================================================

CRITICAL (Do First):
1. Add MixerInsert disposal in dispose() method
2. Add existence check in setInsertGain/setInsertPan
3. Add existence check in addEffectToInsert
4. Implement setMasterPan() method

HIGH PRIORITY (Do Next):
5. Consolidate routing decision logic
6. Add system-aware parameter update method
7. Implement master bus connection synchronization
8. Fix effect ID mapping (use only one ID system)

MEDIUM PRIORITY (Plan):
9. Remove UnifiedMixer hardcoded 28-track limit or use MixerInsert only
10. Add routing validation/visualization
11. Complete MixerInsert integration
12. Add comprehensive error handling

================================================================================
                          TECHNICAL DETAILS
================================================================================

DATA STRUCTURES:

NativeAudioEngine State Maps:
  this.instruments: Map<instrumentId, InstrumentNode>
  this.mixerInserts: Map<insertId, MixerInsert>
  this.instrumentToInsert: Map<instrumentId, insertId>
  this.unifiedMixer: UnifiedMixerNode instance
  this.unifiedMixerChannelMap: Map<channelId, channelIndex 0-31>
  this.mixerChannels: Map<channelId, OldChannelObj> (deprecated, mostly unused)

Master Bus System:
  this.masterBusInput: GainNode (unity 1.0)
  this.masterBusGain: GainNode (unity 1.0)
  this.masterGain: GainNode (default 0.8, user-controllable)
  this.masterAnalyzer: AnalyserNode (metering)
  this.masterEffects: Map (currently empty, for future use)


KEY FILE LOCATIONS:

Core Mixer Files:
  /client/src/lib/core/NativeAudioEngine.js (1441 lines)
    - Main engine, includes both mixer systems
    - createMixerInsert(): 1222-1239
    - removeMixerInsert(): 1245-1269
    - routeInstrumentToInsert(): 1276-1307
    - addEffectToInsert(): 1317-1349
    - setInsertGain(): 1372-1377
    - setInsertPan(): 1384-1389
    - dispose(): 1134-1212

  /client/src/lib/core/MixerInsert.js (375 lines)
    - Dynamic mixer insert class
    - connectInstrument(): 59-72
    - addEffect(): 99-123
    - removeEffect(): 128-151
    - _rebuildChain(): 173-212
    - dispose(): 339-374

  /client/src/lib/core/UnifiedMixerNode.js (384 lines)
    - WASM-based mixer wrapper
    - initialize(): 46-67
    - connectToChannel(): 207-229
    - setChannelParams(): 261-271
    - dispose(): Not implemented (uh-oh!)

Store Integration:
  /client/src/store/useMixerStore.js (762 lines)
    - UI state management
    - handleMixerParamChange(): 71-127
    - handleMixerEffectAdd(): 129-207
    - handleMixerEffectRemove(): 209-246
    - addTrack(): 376-411
    - removeTrack(): 413-472

Service Bridge:
  /client/src/lib/services/AudioContextService.js (2000+ lines)
    - Bridge between store and engine
    - createMixerInsert(): 1782-1801
    - removeMixerInsert(): 1807-1824
    - addEffectToInsert(): 1858-1879
    - removeEffectFromInsert(): 1886-1903
    - setInsertGain(): 1980-1994
    - setInsertPan(): 2001-2015

================================================================================
                         RECOMMENDED ACTIONS
================================================================================

PHASE 1: STABILIZE (This week)
├─ Fix MixerInsert disposal memory leak
├─ Add fallback in parameter update methods
├─ Add existence checks before effect operations
└─ Implement setMasterPan()

PHASE 2: CLARIFY (Next week)
├─ Consolidate routing decision logic
├─ Choose primary mixer system (recommendation: MixerInsert)
├─ Add system-aware parameter update method
└─ Unify master bus connections

PHASE 3: REFACTOR (2-3 weeks)
├─ Remove UnifiedMixer (if staying with MixerInsert)
├─ Simplify ID mapping (single UUID system)
├─ Add routing visualization/validation
└─ Implement comprehensive error handling

================================================================================

CONCLUSION: The mixer is in a hybrid transitional state. The codebase supports
two different mixer systems (UnifiedMixer and MixerInsert) but lacks clear
separation of concerns. This creates maintenance burden, memory leaks, and
silent failures. Recommendation: Complete migration to MixerInsert system and
remove UnifiedMixer.

