import * as Tone from 'tone';
import { timeManager } from './UnifiedTimeManager';
import { InstrumentNode } from './nodes/InstrumentNode.js';
import { MixerStrip } from './nodes/MixerStrip.js';
import { useArrangementStore } from '../../store/useArrangementStore';
import { usePlaybackStore } from '../../store/usePlaybackStore';
import { useInstrumentsStore } from '../../store/useInstrumentsStore';
import { cloneBuffer, normalizeBuffer, reverseBuffer, reversePolarity, removeDCOffset } from '../utils/audioUtils';
import { memoize } from 'lodash';

const memoizedProcessBuffer = memoize(
  (originalBuffer, instData) => {
    if (!originalBuffer) return null;
    let processed = cloneBuffer(originalBuffer);
    if (!processed) return null;
    const effects = instData.precomputed || {};
    if (effects.removeDCOffset) processed = removeDCOffset(processed);
    if (effects.normalize) processed = normalizeBuffer(processed);
    if (effects.reverse) processed = reverseBuffer(processed);
    if (effects.reversePolarity) processed = reversePolarity(processed);
    return processed;
  },
  (originalBuffer, instData) => `${originalBuffer.url || 'buffer'}-${JSON.stringify(instData.precomputed)}`
);

class AudioEngine {
  constructor(callbacks) {
    this.callbacks = callbacks || {};
    
    // DEBUG: Master Fader kontrol√º
    this.masterFader = new Tone.Volume(0).toDestination();
    console.log("üéõÔ∏è [AUDIO ENGINE] Master Fader olu≈üturuldu ve Destination'a baƒülandƒ±", {
      volume: this.masterFader.volume.value,
      connected: this.masterFader.numberOfOutputs > 0
    });
    
    this.instruments = new Map();
    this.mixerStrips = new Map();
    this.scheduledEventIds = new Map();
    this.originalAudioBuffers = new Map();

    this.activePatternId = null;
    this.patterns = {};
    this.playbackMode = 'pattern';

    this.setupTimeManager();
    console.log("üîä Olay Tabanlƒ± Ses Motoru v2.0 Ba≈ülatƒ±ldƒ±.");
  }

  setupTimeManager() {
    timeManager.onPositionUpdate = (position) => this.callbacks.setTransportPosition?.(position.formatted);
    timeManager.onLoopInfoUpdate = (loopInfo) => this.callbacks.setLoopLengthFromEngine?.(loopInfo.lengthInSteps);
  }

  async syncFromStores(instrumentData, mixerTrackData, arrangementData) {
    console.log("%c[SYNC] Proje verileri ses motoruna y√ºkleniyor...", "color: #818cf8; font-weight: bold;");
    
    // DEBUG: Gelen verileri kontrol et
    console.log("üìä [SYNC DEBUG] Gelen veriler:", {
      instrumentCount: instrumentData.length,
      mixerTrackCount: mixerTrackData.length,
      patternCount: Object.keys(arrangementData.patterns).length,
      instruments: instrumentData.map(i => ({ id: i.id, name: i.name, mixerTrackId: i.mixerTrackId })),
      mixerTracks: mixerTrackData.map(t => ({ id: t.id, name: t.name, type: t.type }))
    });
    
    this.patterns = arrangementData.patterns;
    this.activePatternId = arrangementData.activePatternId;
    this.playbackMode = usePlaybackStore.getState().playbackMode;

    // 1. T√ºm mikser kanallarƒ±nƒ± olu≈ütur
    console.log("üéöÔ∏è [SYNC] Mikser kanallarƒ± olu≈üturuluyor...");
    for (const trackData of mixerTrackData) {
      this.createMixerStrip(trackData);
    }

    // 2. T√ºm mikser kanallarƒ±nƒ±n ses zincirini kur
    console.log("üîó [SYNC] Mikser ses zincirleri kuruluyor...");
    await this._buildAllSignalChains(mixerTrackData);

    // 3. T√ºm enstr√ºmanlarƒ± olu≈ütur ve miksere baƒüla
    console.log("üéπ [SYNC] Enstr√ºmanlar olu≈üturuluyor...");
    for (const instData of instrumentData) {
      await this.createInstrument(instData);
    }
    
    // DEBUG: Final durumu kontrol et
    console.log("üîç [SYNC DEBUG] Final durum:", {
      instrumentsCreated: this.instruments.size,
      mixerStripsCreated: this.mixerStrips.size,
      masterFaderVolume: this.masterFader.volume.value
    });
    
    // 4. Notalarƒ± zaman √ßizelgesine yerle≈ütir
    this.reschedule();
    console.log("%c[SYNC] Y√ºkleme tamamlandƒ±. Motor hazƒ±r.", "color: #34d399; font-weight: bold;");
  }

  createMixerStrip(trackData) {
    if (this.mixerStrips.has(trackData.id)) {
      console.log(`‚ö†Ô∏è [MIXER] Kanal zaten var, atlanƒ±yor: ${trackData.id}`);
      return;
    }
    
    const strip = new MixerStrip(trackData);
    this.mixerStrips.set(trackData.id, strip);
    console.log(`‚úÖ [AUDIO] Mixer kanalƒ± olu≈üturuldu: ${trackData.name} (${trackData.id})`, {
      hasInputGain: !!strip.inputGain,
      hasOutputGain: !!strip.outputGain
    });
  }

  async createInstrument(instData) {
    if (this.instruments.has(instData.id)) {
      console.log(`‚ö†Ô∏è [INSTRUMENT] Enstr√ºman zaten var, atlanƒ±yor: ${instData.id}`);
      return;
    }
    
    console.log(`üéµ [INSTRUMENT] Olu≈üturuluyor: ${instData.name} (${instData.id})`);
    
    const instrumentNode = new InstrumentNode(instData);
    this.instruments.set(instData.id, instrumentNode);
    
    // Y√ºkleme tamamlanmasƒ±nƒ± bekle
    try {
      await instrumentNode.readyPromise;
      console.log(`‚úÖ [INSTRUMENT] Y√ºklendi: ${instData.name}`);
      
      // Buffer'ƒ± sakla
      if (instrumentNode.sampler.loaded) {
        this.originalAudioBuffers.set(instData.id, instrumentNode.sampler.buffer);
      }
      
      // Mixer'a baƒüla
      this.connectInstrumentToMixer(instData.id, instData.mixerTrackId);
      
    } catch (error) {
      console.error(`‚ùå [INSTRUMENT] Y√ºkleme hatasƒ±: ${instData.name}`, error);
    }
  }
  
  connectInstrumentToMixer(instrumentId, mixerTrackId) {
    const instrumentNode = this.instruments.get(instrumentId);
    const targetStrip = this.mixerStrips.get(mixerTrackId);

    if (!instrumentNode) {
      console.error(`‚ùå [ROUTING] Enstr√ºman bulunamadƒ±: ${instrumentId}`);
      return;
    }
    
    if (!targetStrip) {
      console.error(`‚ùå [ROUTING] Mixer kanalƒ± bulunamadƒ±: ${mixerTrackId}`);
      return;
    }

    try {
      instrumentNode.output.disconnect();
      instrumentNode.output.connect(targetStrip.inputGain);
      console.log(`üîó [AUDIO] Baƒülantƒ± yapƒ±ldƒ±: ${instrumentNode.id} -> ${targetStrip.id}`, {
        instrumentOutput: instrumentNode.output,
        stripInput: targetStrip.inputGain
      });
    } catch (error) {
      console.error(`‚ùå [ROUTING] Baƒülantƒ± hatasƒ±:`, error);
    }
  }

  _buildAllSignalChains(mixerTrackData) {
    const busInputs = new Map();
    
    // DEBUG: Bus inputs toplama
    console.log("üöå [ROUTING] Bus inputlarƒ± toplanƒ±yor...");
    mixerTrackData.forEach(track => {
      if (track.type === 'bus') {
        const strip = this.mixerStrips.get(track.id);
        if (strip?.inputGain) {
          busInputs.set(track.id, strip.inputGain);
          console.log(`‚úÖ [ROUTING] Bus input eklendi: ${track.id}`);
        }
      }
    });

    // DEBUG: Her kanal i√ßin signal chain kurulumu
    console.log("‚õìÔ∏è [ROUTING] Signal chain'ler kuruluyor...");
    for (const trackData of mixerTrackData) {
      const strip = this.mixerStrips.get(trackData.id);
      if (strip) {
        console.log(`üîß [ROUTING] Signal chain kuruluyor: ${trackData.id} (${trackData.type})`);
        strip.buildSignalChain(trackData, this.masterFader, busInputs);
      }
    }
  }

  async requestInstrumentBuffer(instrumentId) {
    const node = this.instruments.get(instrumentId);
    if (!node) {
      console.error(`‚ùå [requestInstrumentBuffer] Enstr√ºman bulunamadƒ±: ${instrumentId}`);
      return null;
    }

    await node.readyPromise;
    return node.sampler.buffer;
  }

  reconcileInstrument(instrumentId, updatedInstData) {
    console.log(`üîÑ [RECONCILE] ${instrumentId} i√ßin buffer yeniden i≈üleniyor...`, updatedInstData.precomputed);
    const originalBuffer = this.originalAudioBuffers.get(instrumentId);
    const instrumentNode = this.instruments.get(instrumentId);

    if (!originalBuffer || !instrumentNode) {
      console.error(`‚ùå [RECONCILE] Hata: Orijinal buffer veya enstr√ºman bulunamadƒ±: ${instrumentId}`);
      return null;
    }

    const newProcessedBuffer = memoizedProcessBuffer(originalBuffer, updatedInstData);
    instrumentNode.sampler.buffer = newProcessedBuffer;
    console.log(`‚úÖ [RECONCILE] ${instrumentId} i√ßin buffer g√ºncellendi.`);
    
    return newProcessedBuffer;
  }

  updateMixerParam = (trackId, param, value) => {
    const strip = this.mixerStrips.get(trackId);
    if (strip) {
      console.log(`üéõÔ∏è [MIXER] Parametre g√ºncelleniyor: ${trackId}.${param} = ${value}`);
      strip.updateParam(param, value);
    }
  }

  updateEffectParam = (trackId, effectId, param, value) => {
    this.mixerStrips.get(trackId)?.updateEffectParam(effectId, param, value);
  }

  toggleMute = (trackId, isMuted) => {
    this.mixerStrips.get(trackId)?.setMute(isMuted);
  }

  reschedule() {
    console.log('%c[RESCHEDULE] Notalar yeniden zamanlanƒ±yor...', 'color: orange; font-weight: bold;');
    
    // √ñnceki zamanlamalarƒ± temizle
    Tone.Transport.cancel(0);
    this.scheduledEventIds.clear();
    
    // Store'lardan g√ºncel veriyi al
    this.patterns = useArrangementStore.getState().patterns;
    this.activePatternId = useArrangementStore.getState().activePatternId;
    this.playbackMode = usePlaybackStore.getState().playbackMode;
    const instruments = useInstrumentsStore.getState().instruments;

    console.log(`[RESCHEDULE] Mod: ${this.playbackMode}, Aktif Pattern ID: ${this.activePatternId}`);
    
    // DEBUG: Enstr√ºman durumu
    console.log("üéπ [RESCHEDULE DEBUG] Enstr√ºman durumu:", {
      storeInstruments: instruments.length,
      engineInstruments: this.instruments.size,
      instrumentIds: Array.from(this.instruments.keys())
    });

    // Time manager g√ºncelleme
    const arrangementData = useArrangementStore.getState();
    timeManager.calculateLoopInfo(this.playbackMode, this.activePatternId, arrangementData);

    // Pattern kontrol√º
    const activePattern = this.patterns?.[this.activePatternId];
    if (!activePattern) {
      console.warn('‚ö†Ô∏è [RESCHEDULE] Aktif pattern bulunamadƒ±.');
      return;
    }
    if (this.playbackMode !== 'pattern') {
      console.log('‚ÑπÔ∏è [RESCHEDULE] Song modunda, pattern zamanlamasƒ± atlanƒ±yor.');
      return;
    }
    
    console.log(`‚úÖ [RESCHEDULE] Aktif Pattern: "${activePattern.name}"`);
    let totalScheduledNotes = 0;

    // Notalarƒ± zamanla
    Object.entries(activePattern.data).forEach(([instId, notes]) => {
      const inst = instruments.find(i => i.id === instId);
      if (!inst || inst.isMuted || !notes || notes.length === 0) {
        return;
      }
      
      const node = this.instruments.get(instId);
      if (!node) {
        console.warn(`‚ö†Ô∏è [RESCHEDULE] Enstr√ºman d√ºƒü√ºm√º bulunamadƒ±: ${instId}`);
        return;
      }
      
      // DEBUG: Node durumunu kontrol et
      console.log(`üéµ [RESCHEDULE] ${inst.name}: ${notes.length} nota zamanlanƒ±yor`, {
        nodeReady: node.isReady,
        samplerLoaded: node.sampler?.loaded
      });
      
      let scheduledCountForInst = 0;

      notes.forEach(note => {
        const step = note.time;
        const timeNotation = `${Math.floor(step / 16)}:${Math.floor((step % 16) / 4)}:${step % 4}`;
        
        try {
          const eventId = Tone.Transport.schedule(time => {
            if (node && typeof node.trigger === 'function') {
              console.log(`üé∂ [TRIGGER] ${inst.name} √ßalƒ±yor: ${timeNotation}`);
              node.trigger(time, note, null, inst.cutItself);
            }
          }, timeNotation);
          this.scheduledEventIds.set(`${instId}-${note.id || note.time}`, eventId);
          scheduledCountForInst++;
        } catch (e) {
          console.error(`‚ùå [RESCHEDULE] Nota zamanlanamadƒ±: ${inst.name}`, e);
        }
      });
      totalScheduledNotes += scheduledCountForInst;
    });
    
    console.log(`%c[RESCHEDULE] Tamamlandƒ±. ${totalScheduledNotes} nota zamanlandƒ±.`, 'color: lightgreen; font-weight: bold;');
  }

  start() {
    console.log("‚ñ∂Ô∏è [TRANSPORT] Start komutu alƒ±ndƒ±");
    
    // AudioContext durumunu kontrol et
    if (Tone.context.state !== 'running') {
      console.log("üîä [TRANSPORT] AudioContext ba≈ülatƒ±lƒ±yor...");
      Tone.context.resume();
    }
    
    // Transport durumunu kontrol et
    console.log(`üìä [TRANSPORT DEBUG]`, {
      contextState: Tone.context.state,
      transportState: Tone.Transport.state,
      bpm: Tone.Transport.bpm.value,
      masterVolume: this.masterFader.volume.value
    });
    
    this.reschedule();
    timeManager.start(this.playbackMode, this.activePatternId, useArrangementStore.getState());
    Tone.Transport.start();
    this.callbacks.setPlaybackState?.('playing');
    
    console.log("‚úÖ [TRANSPORT] Playback ba≈üladƒ±");
  }

  stop() {
    console.log("‚èπÔ∏è [TRANSPORT] Stop komutu alƒ±ndƒ±");
    Tone.Transport.stop();
    timeManager.stop();
    this.callbacks.setPlaybackState?.('stopped');
  }

  pause() {
    console.log("‚è∏Ô∏è [TRANSPORT] Pause komutu alƒ±ndƒ±");
    Tone.Transport.pause();
    timeManager.pause();
    this.callbacks.setPlaybackState?.('paused');
  }
  
  setBpm(newBpm) {
    console.log(`üéµ [BPM] Yeni BPM: ${newBpm}`);
    Tone.Transport.bpm.value = newBpm;
    this.reschedule();
  }

  dispose() {
    this.stop();
    timeManager.dispose();
    this.instruments.forEach(inst => inst.dispose());
    this.mixerStrips.forEach(strip => strip.dispose());
    console.log("üî• Ses Motoru ve t√ºm bile≈üenleri temizlendi.");
  }
}

export default AudioEngine;